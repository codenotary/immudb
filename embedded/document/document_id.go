/*
Copyright 2023 Codenotary Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package document

import (
	"crypto/rand"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"sync/atomic"
	"time"
)

/*
	DocumentID is a 16-byte identifier that is automatically generated
	by the server upon document insertion. The 16-byte DocumentID is composed of:

		1) A 4-byte timestamp value, representing the time the document was created,
		measured in seconds since the Unix epoch.
		2) A 8-byte value, initialized to the previous transaction id.
		3) A 4-byte incremental counter value, generated using a secure random number generator.

	The timestamp portion of the DocumentID allows documents to be sorted by creation time, which
	can be useful for certain types of queries. The tx id portions of the DocumentID ensure that
	the identifier is unique across all documents in a collection, even if multiple documents
	are inserted in the same second. The 4-byte value ensures randomness.
*/

// DocumentIDLength is the length of a DocumentID.
const DocumentIDLength = 16

// DocumentID is a 16-byte identifier that is automatically generated by the server upon document insertion.
type DocumentID [DocumentIDLength]byte

// NilDocumentID is the zero value for DocumentID.
var NilDocumentID DocumentID

// documentIDCounter is a counter used to generate unique monotically incremental number for the document id.
var documentIDCounter = getRandUint32()

// NewDocumentIDFromTx generates a new DocumentID.
func NewDocumentIDFromTx(txID uint64) DocumentID {
	return NewDocumentIDFromTimestamp(time.Now(), txID)
}

// NewDocumentIDFromBytes generates a new DocumentID from a byte slice.
func NewDocumentIDFromBytes(b []byte) DocumentID {
	// copy from bytes to DocumentID
	var id DocumentID
	copy(id[:], b)
	return id
}

// NewDocumentIDFromTimestamp generates a new DocumentID from a timestamp.
func NewDocumentIDFromTimestamp(timestamp time.Time, txID uint64) DocumentID {
	var b [DocumentIDLength]byte

	// The first 4 bytes are the timestamp.
	binary.BigEndian.PutUint32(b[0:4], uint32(timestamp.Unix()))

	// The next 8 bytes are the precommitted transaction id.
	binary.BigEndian.PutUint64(b[4:12], txID)

	// The next 4 bytes are the monotically increasing number.
	counter := atomic.AddUint32(&documentIDCounter, 1)
	binary.BigEndian.PutUint32(b[12:16], counter)

	return b
}

// Timestamp returns the timestamp portion of the DocumentID.
func (id DocumentID) Timestamp() time.Time {
	unixSecs := binary.BigEndian.Uint32(id[:])
	return time.Unix(int64(unixSecs), 0).UTC()
}

// Hex returns the hex representation of the DocumentID.
func (id DocumentID) Hex() string {
	var buf [32]byte
	hex.Encode(buf[:], id[:])
	return string(buf[:])
}

// DocumentIDFromHex returns a DocumentID from a hex string.
func DocumentIDFromHex(s string) (DocumentID, error) {
	if len(s) != 32 {
		return NilDocumentID, errors.New("invalid hex length for DocumentID")
	}

	var oid [DocumentIDLength]byte
	_, err := hex.Decode(oid[:], []byte(s))
	if err != nil {
		return NilDocumentID, err
	}

	return oid, nil
}

func getRandUint32() uint32 {
	var b [4]byte
	_, err := io.ReadFull(rand.Reader, b[:])
	if err != nil {
		panic(fmt.Errorf("cannot initialize document id rand reader: %v", err))
	}

	return binary.BigEndian.Uint32(b[0:4])
}
